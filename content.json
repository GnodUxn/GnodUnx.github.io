{"meta":{"title":"GnodUxn's Blog","subtitle":null,"description":"Talk less and do more.","author":"GnodUxn","url":"http://yoursite.com/child"},"pages":[{"title":"About","date":"2018-06-24T11:09:07.000Z","updated":"2018-06-24T11:09:07.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/child/about/index.html","excerpt":"","text":"现居北京，就职于北京裕福支付有限公司，负责跨境项目开发。 个人邮箱：wxd.engineer@gmail.com博客地址：http://www.cnblogs.com/wanxudong/"},{"title":"Tags","date":"2017-09-28T16:00:14.000Z","updated":"2017-09-28T15:12:30.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/child/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-09-28T16:00:14.000Z","updated":"2017-09-28T15:12:30.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/child/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Black Mirror - White Bear Review","slug":"2017-09-23-black-mirror-white-bear-review","date":"2017-09-23T08:10:56.000Z","updated":"2017-10-23T09:00:46.000Z","comments":true,"path":"2017/09/23/2017-09-23-black-mirror-white-bear-review/","link":"","permalink":"http://yoursite.com/child/2017/09/23/2017-09-23-black-mirror-white-bear-review/","excerpt":"黑镜是本人今年看过最好的迷你剧。尽管本剧第一季2011年12月播出，直到今年我才看到。但这丝毫不影响我对这部剧的喜爱。黑镜包括第一季、第二季、圣诞特辑和第三季构成，每集都是一个独立的故事。每次看完心情都会变得很复杂，会有种细思极恐的感觉。而《White Bear》这集更是让我内心久久不能平复，对正义与邪恶的区分放佛更加模糊，促使我不断的在思考究竟是什么促使这个社会的文明与进步。","text":"黑镜是本人今年看过最好的迷你剧。尽管本剧第一季2011年12月播出，直到今年我才看到。但这丝毫不影响我对这部剧的喜爱。黑镜包括第一季、第二季、圣诞特辑和第三季构成，每集都是一个独立的故事。每次看完心情都会变得很复杂，会有种细思极恐的感觉。而《White Bear》这集更是让我内心久久不能平复，对正义与邪恶的区分放佛更加模糊，促使我不断的在思考究竟是什么促使这个社会的文明与进步。 故事开篇是一个精神混乱的黑人女性在椅子上醒来，她并不知道自己是谁，能看到的只有地上散落的药片以及腕上的伤痕。在楼下，她看到了自己与一个男人的合照以及一张小女孩的照片。记忆中她放佛看到了小女孩单纯的笑，这短暂的回忆已经让她头疼欲裂。走出屋外，除了玻璃窗上看到的拿着手机拍照的人外，街上空无一人。当戴着面具的枪手开始追杀她的时候，越来越多的人从屋里走出来，面无表情，如行尸走肉般的拿着手机跟拍她被追杀的场景。 跑到加油站的时候遇到了一个帮助她逃跑的女人，女人告诉她当人们看到屏幕上闪动的信号时几乎都变成了看客，她们需要到一个叫“white bear”的信号发射站去摧毁发射机。在发射站中，正当她们试图关掉发射机时，那群追杀她的杀手赶到了。千钧一发之际，女主夺过了杀手手中的枪。她扣动了扳机，打出来的却是彩纸。这时，背后的墙缓缓打开，出现在她眼前的是看台上观众欢呼鼓掌的画面。女主在错愕中被绑到了椅子上，紧接着出现一个主持人告诉了她真相。 原来，女主和其未婚夫绑架了六岁的小女孩，而那次搜寻小女孩的行动是以找到的小女孩的白色泰迪熊为标志，就是“白熊”。其未婚夫把小女孩虐待致死，而她在一边用手机记录了小女孩的临终时刻。虽然她辩解说是未婚夫强迫她拍摄，并称是受了蛊惑，但陪审团和法官还是一致认为她心地歹毒、冷漠无情，理应适当增刑！由于她的未婚夫在狱中上吊自杀逃脱了法律的制裁，公众随即将目光转向了同谋者—女主身上。人们建立了“白熊正义公园”，像围观动物一样参观女主日复一日被消除记忆，然后被虐待追杀，而身边全是带着家庭来参观的冷漠的、举着手机的旁观者。 看到最后的时候内心无比承重，一方面是对女主及其未婚夫绑架虐杀小女孩的痛恨，一方面是对此种所谓正义的审判方式的恐惧。当所有人都去默许旁观这种以暴制暴的审判方式的时候，他们又是否能够代表正义？现实生活中的“你不仁我不义”、“以牙还牙、以眼还眼”，到底是法制的进步还是文明的倒退？ 生活中总有些人以自己的方式理解世界，大家心中各有一把衡量正义的标尺。但随着科技的发展，自媒体应用而生。更多私人化、平民化的媒体进入我们的生活，引导我们的价值。每当有公众事件发生的时候总少不了一大帮人的围观热议，有些极端的人甚至动不动就发起所谓“人肉搜索”给事件当事人带来无尽的困扰与精神折磨，这种日复一日的过程是否与《White Bear》中的主人公所经历的一样。诚然，其中大部分人也不过只是从众围观，将其当作茶余饭后的谈资，当事件偃旗息鼓后早已将之抛之脑后。但“网络暴力”对当事人的折磨将是永无止境的，这些方式和罪犯又有什么区别呢？ 知乎上一篇名为《人到底可以有多坏？》的话题高达13万关注者，正如题主所说的“这个世界上也不仅仅有好人。可能有些人不算坏人，但是有可能会因为利益或者其他而伤害别人。”。从哲学的角度来说，善与恶原本就是矛盾的两个方面，是相互转化的。没有十足的恶人，正如没有完美的好人，人性本就是复杂的。有些人罪大恶极、穷凶极恶，他们是该死，但审判与处罚权并不在每个人手中。如果大家都按照自己的意愿去惩罚罪恶，那么血腥暴力和恐惧将成为生活的全部。社会文明的进步就是我们以更理性的方式去处理社会矛盾，法律作为严谨，庄严和公正的化身将代替我们惩治罪犯。也许法律也有遗漏，有灰色地带，但正因为这样我们才要共同去完善并遵循它。 我不是圣人，我的愿望也没有大到维护世界和平，我只是个程序员，不恣意，不妄为，简单生活，认真工作。","categories":[{"name":"Review","slug":"Review","permalink":"http://yoursite.com/child/categories/Review/"}],"tags":[]},{"title":"KVO实现原理","slug":"2017-09-15-kvoshi-xian-yuan-li","date":"2017-09-15T02:32:55.000Z","updated":"2017-10-13T04:07:56.000Z","comments":true,"path":"2017/09/15/2017-09-15-kvoshi-xian-yuan-li/","link":"","permalink":"http://yoursite.com/child/2017/09/15/2017-09-15-kvoshi-xian-yuan-li/","excerpt":"有关KVO (Key-Value Observing)大家一定不会觉得陌生，常常被用来监听某个对象属性值的改变。那么有关底层实现原理是需要来探讨的，今天就来说说KVO的基本使用以及实现原理。","text":"有关KVO (Key-Value Observing)大家一定不会觉得陌生，常常被用来监听某个对象属性值的改变。那么有关底层实现原理是需要来探讨的，今天就来说说KVO的基本使用以及实现原理。 什么是KVO KVO (Key-Value Observing) 是 Objective-C 对观察者模式（Observer Pattern）的实现。当被观察者对象的某个被观察属性发生变化时，观察者对象会获得通知。 苹果官方文档中对KVO的定义是 Automatic key-value observing is implemented using a technique called isa-swizzling. The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data. When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance. You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance. 从中可以看到并不想我们想象的那么简单，KVO的实现中使用了黑魔法 isa-swizzling，后面将描述其实现过程。 下面先来看KVO的基本使用。 KVO的基本使用以下使用官方文档中的Example为例（官方文档）。 创建两个类，Person类和Account类。假使一个Person对象拥有一个Account对象，代表一个人在银行的储蓄账号。这样，当银行的收益和利率变化时这个人必须时刻注意到。在Account类中添加两个公共属性，如图所示： 既然Account类的属性是公共的，Person对象可以通过轮询查找来获取Account属性值的变化，但显然这样效率低下。 1、为Person对象添加监听对象，调用方法：addObserver:forKeyPath:options:context: 。 2、在Person类中实现observeValueForKeyPath:ofObject:change:context:方法。这样，当Account属性值发生变化时就会调用此方法，将其值的变化通知过来。 3、最后，当不再希望收到通知时一定要在Person类销毁时注销通知，调用removeObserver:forKeyPath:方法。 实现原理KVO是基于Runtime实现的，其实现过程 ChenYilong (微博@iOS程序犭袁)在下面这张图中画的很明白。 当观察一个对象的时候，运行期系统会动态创建一个新的类。 这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后（被观察属性发生改变之前 willChangeValueForKey:方法会被调，被观察的属性发生改变之后didChangeValueForKey:方法则会被调用），通知所有观察对象：值的更改。 最后通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。 感谢ChenYilong 在《《招聘一个靠谱的 iOS》—参考答案（下）》中的精彩答案，节省了我很多时间去研究KVO的实现细节。 手写KVO这里推荐Glow 技术团队博客上的一篇文章《如何自己动手实现 KVO》，文章里关于KVO实现细节是我在网上看到最全的，而且附带源码。感兴趣的同学可以去看看。这里就不浪费空间贴大量代码了。 KVO的不足KVO一度被认为是非常不好的API，比如其 以字符串作为关键字、remove observer不当会导致crash，《Key-Value Observing Done Right》、《KVO Considered Harmful》以及Mattt Thompson在《Key-Value Observing》中都强调了KVO的不足之处，有兴趣可以去看下。 参考文章 Key-Value Observing Programming Guide 《招聘一个靠谱的 iOS》—参考答案（下） 如何自己动手实现 KVO Key-Value Observing Key-Value Observing Done Right KVO Considered Harmful","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/categories/iOS/"}],"tags":[]},{"title":"Block那点事儿","slug":"2017-08-22-guan-yu-blockwo-you-hua-shuo","date":"2017-08-22T09:34:59.000Z","updated":"2017-10-13T04:15:13.000Z","comments":true,"path":"2017/08/22/2017-08-22-guan-yu-blockwo-you-hua-shuo/","link":"","permalink":"http://yoursite.com/child/2017/08/22/2017-08-22-guan-yu-blockwo-you-hua-shuo/","excerpt":"关于Block相信每一个iOS开发者都不会陌生，不管是偏爱哪种传值方式（Block还是delegate），都或多或少都接触过Block。以下我将参考网上各路大神的分析并结合自己的实践对Block进行一次详尽分析。若有不足之处，欢迎联系指正。","text":"关于Block相信每一个iOS开发者都不会陌生，不管是偏爱哪种传值方式（Block还是delegate），都或多或少都接触过Block。以下我将参考网上各路大神的分析并结合自己的实践对Block进行一次详尽分析。若有不足之处，欢迎联系指正。 写本篇文章的初衷是一次面试中被问及“Block的原理”，平日里项目中经常使用Block，关于Block的种类以及注意事项也烂熟于心。被问及这个问题时第一时间想到的是当初用clang编译的C源码（一些复杂的C方法名和变量），苦于记忆模糊和表达能力有限以致于不知该怎么表达这个原理性的问题。回来后痛定思痛，决不能抱着对知识一知半解的态度去学习，因此决定系统化的梳理一遍Block的知识点。 定义 ####什么是Block 在《Objective-C和OS X高级编程》这本书中，作者是这么定义的： Block是C语言的扩充功能。可以用一句话来表示Block的扩充功能：带有自动变量（局部变量）的匿名函数。顾名思义，所谓匿名函数就是不带有名称的函数。 唐巧大神在 谈Objective-C block的实现 中则是引用了 wikipedia 上对闭包的定义： Closure (computer programming) In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variablesor upvalues) of that function. “ 翻译过来，闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。 block 实际上就是 Objective-C 语言对于闭包的实现。” block的内部结构 block 的内存布局如下图 “ 每个Objective-C对象都占据着某个内存区域。因为实例变量的个数及对象所包含的关联数据互不相同，所以每个对象所占据的内存区域也有大有小。Block本身也是对象，在存放block的内存区域中，首个变量是指向Class对象的指针，该指针叫做 isa 。其余内存里含有 Block 对象正常运转所需的各种信息。” — 摘自《Effective Objective-C 2.0》 下面介绍该数据结构中的变量： isa 指针：所有对象都有该指针，用于实现对象相关的功能。 flags：表示一些 block 的附加信息。 reserved：保留变量。 invoke：函数指针，指向block的实现代码。 descriptor： 指向结构体的指针，每个block里都包含此结构体，其中声明了block对象的总体大小，还声明了copy与dispose这两个辅助函数所对应的函数指针。比如，copy保留捕获的对象，dispose则将之释放。 variables：捕获的变量，捕获多少个变量，就要占据多少内存空间。 源码分析 初识block 工具：clang 首先新建打开工程，在main.m文件中写如下代码： 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int a = 10; void (^blk)(void) = ^&#123; printf(&quot;Hello word! a = %d\\n&quot;,a); &#125;; blk(); &#125; return 0;&#125; 打开终端，cd到main.m文件所在目录，在终端输入：clang -rewrite-objc main.m，即可在目录中看到 clang 输出了一个名为 main.cpp 的文件。该文件就是 block 的 C 语言实现。 打开该文件就会看到上百行的代码，其实有用的信息只有三十几行代码。下面我将关键代码贴过来： 123456789101112131415161718192021222324252627282930313233struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy printf(&quot;Hello word! a = %d\\n&quot;,a); &#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; int a = 10; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); &#125; return 0;&#125; 首先来看__main_block_impl_0结构体，由于其构造函数也一并写入结构体中，稍显复杂。除去其构造函数将变得十分简单。 1234struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc;&#125;; 第一个成员变量是__block_impl，先看一下其结构体的声明： 123456struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;; 从其变量名称可以联想到某些标志、今后版本升级所需的区域以及指针函数。 第二个成员变量是Desc指针，其结构体声明如下： 1234static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; 从变量名可知，其结构为今后版本升级所需的区域和Block的大小。 下面我们来看__main_block_impl_0结构体的构造函数： 123456__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc;&#125; 从 impl.isa = &amp;_NSConcreteStackBlock 可知，block的实质就是Objective-C对象，关于该类的信息在_NSConcreteStackBlock中。 其中 fp 为指向 __main_block_func_0函数的指针。 Tips: isa 指向一个类对象，该实例持有声明的成员变量、方法的名字、方法的实现（即函数指针）、属性以及父类的指针，并被Objective-C运行时库所使用。 接下来来看对上面构造函数的调用。 12void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); WTF !!! 这是什么鬼？还好有业界的各位巨人，以至于我可以站在巨人的肩膀上。《Objective-C和OS X高级编程》这本书中对block有详细的讲解，有兴趣的可以去看，这里不再赘述。我们将转换去掉就变成了下面这样： 12struct __main_block_impl_0 temp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);struct __main_block_impl_0 *blk = &amp;temp; 将 __main_block_impl_0 结构体类型的自动变量，栈上生成的 __main_block_impl_0 结构体实例的指针，赋值给 __main_block_impl_0 结构体指针类型的变量blk。 下面看 main_block_impl_0 结构体实例的构造参数。第一个参数是C语言函数指针，第二个参数作为静态全局变量初始化的__main_block_desc_0结构体实例指针。__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA)返回函数指针，而使用__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA) (); 就是简单的使用函数指针调用函数。由block语法转换的__main_block_func_0函数的指针被赋值成员变量FuncPtr中。另外，__main_block_func_0函数的参数__cself指向block的值。在调用该函数的源代码中可以看到block正是作为参数进行了传递。 block的分类(MRC下) 由前文可知，block的实质是Objective-C对象。上文的block类型为 _NSConcreteStackBlock ，其实block共有三种类型： _NSConcreteStackBlock : 该block设置在栈上。 _NSConcreteGlobalBlock : 与全局变量一样，该block设置在数据区（.data区）。 _NSConcreteMallocBlock : 该类设置在由malloc函数分配的内存块（堆）上。 内存分布图如下： 上文的block为 _NSConcreteStackBlock ，这种block需捕获状态（如变量等），运行时也有状态参与进来。 _NSConcreteGlobalBlock 当不需捕获变量也无状态参与的时候在数据区存储。如： 12345678910void (^block)() = ^(void)&#123; printf(&quot;Global Block\\n&quot;);&#125;;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; block(); &#125; return 0;&#125; 其 isa 指针指向 _NSConcreteGlobalBlock 。 _NSConcreteMallocBlock ，如下面代码所示： 123456789101112typedef int(^blk_t)(int);blk_t func(int rate)&#123; return [^(int count)&#123;return rate * count;&#125; copy];&#125;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; blk_t mallocBlk = func(2); NSLog(@&quot;%@&quot;,mallocBlk); &#125; return 0;&#125; 在MRC下 return ^(int count){return rate * count;}; 会报错：Returning block that on the local stack 说明返回的是配置在栈上的Block。即程序执行中从该函数返回函数调用方法时变量作用域结束，因此栈上的Block也被废弃。所以在MRC下编译需改为 return [^(int count){return rate * count;} copy];。 源码中可以看到：impl.isa = &amp;_NSConcreteStackBlock; 依旧指向栈上，但其打印出的Block类型为 __NSMallocBlock__ ，这里一度让我疑惑不已。直到看到Clang官方文档的一句话： “ The initial allocation is done on the stack， but the runtime provides a Block_copy function ” 。那么 Block_copy 函数做了什么？它负责将栈上的Block复制到堆上，但这一切都是在运行时执行的。 那么什么时候栈上的Block会被复制到堆上呢？ 调用Block的copy方法时。 Block作为函数返回值返回时。 将Block赋值给带有 __strong 修饰符 id 类型的类或Block类型成员变量时。 在方法名中含有 usingBlock 的 Cocoa 框架方法或 GCD 的 API 中传递 Block 时。 __block的使用 当使用__block修饰变量的时候，编译器会成一个新的结构体，如下 1234567struct __Block_byref_a_0 &#123; void *__isa;__Block_byref_a_0 *__forwarding; int __flags; int __size; int a;&#125;; 其中 __forwarding指针是指向自己的指针。当栈上的Block被复制到堆上时，会将成员变量 __forwarding 的值替换成复制目标堆上的 __block 变量用结构体实例的地址。 1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; __block之所以能改变变量的值，不仅仅是因为 __main_block_impl_0 结构体实例中传入的成员变量是变量的地址，而是编译器通过生成指向 __Block_byref_a_0 结构体的 __forwarding 指针，保证无论通过 __block 修饰变量配置在栈上还是堆上，都能保证正确访问。 ARC对Blcok的影响 ARC开启的情况下不需要手动将Block从栈复制到堆。而且只会产生NSConcreteGlobalBlock 和 NSConcreteMallocBlock 类型的 Block。例如文章开始的代码： 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int a = 10; void (^blk)(void) = ^&#123; printf(&quot;Hello word! a = %d\\n&quot;,a); &#125;; blk(); NSLog(@&quot;%@&quot;,blk); &#125; return 0;&#125; 在ARC环境下控制台打印结果为：__NSMallocBlock__类型的Block。所以在ARC环境下，当Block不需捕获变量也无状态参与的时候生成 __NSGlobalBlock__类型的Block，_NSConcreteStackBlock 类型的Block会在运行时编译器的优化下变成 __NSMallocBlock__类型的Block。 结论有关Block的问题暂时先写这么多，之后有了新的理解会随时补充。 参考文章 Block Implementation Specification BlocksRuntime 谈Objective-C block的实现 Block内存管理实例分析 《Objective-C和OS X高级编程》","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/categories/iOS/"}],"tags":[]},{"title":"轻量级视图控制器","slug":"2017-06-08-qing-liang-ji-shi-tu-kong-zhi-qi","date":"2017-06-08T08:06:43.000Z","updated":"2017-10-23T09:24:16.000Z","comments":true,"path":"2017/06/08/2017-06-08-qing-liang-ji-shi-tu-kong-zhi-qi/","link":"","permalink":"http://yoursite.com/child/2017/06/08/2017-06-08-qing-liang-ji-shi-tu-kong-zhi-qi/","excerpt":"本文翻译自：Lighter View Controllers 在iOS项目中视图控制器通常是最大的文件，它们通常包含许多非必要的代码。视图控制器几乎总是代码里最少被复用的部分。接下来我们将使用技巧使视图控制器瘦身、复用代码、并把代码放到适当的地方。 此问题的示例代码在GitHub上。","text":"本文翻译自：Lighter View Controllers 在iOS项目中视图控制器通常是最大的文件，它们通常包含许多非必要的代码。视图控制器几乎总是代码里最少被复用的部分。接下来我们将使用技巧使视图控制器瘦身、复用代码、并把代码放到适当的地方。 此问题的示例代码在GitHub上。 将数据源和其他协议分开为控制器瘦身最强有力技巧之一是将UITableViewDataSource部分的代码移动到它自己的类中。如果你不止一次这样做过了，你将会发现一种特有的模式并提取出可复用的代码。 举个例子，在我们的示例程序中，有一个名为PhotosViewController的类包含以下方法： 12345678910111213141516171819# pragma mark Pragma - (Photo*)photoAtIndexPath:(NSIndexPath*)indexPath &#123; return photos[(NSUInteger)indexPath.row];&#125;- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section &#123; return photos.count;&#125;- (UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath &#123; PhotoCell* cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier forIndexPath:indexPath]; Photo* photo = [self photoAtIndexPath:indexPath]; cell.label.text = photo.name; return cell;&#125; 这些代码中多次用到了数组，其中一些特定用于视图控制器管理的照片。所以，我们试着将与数组相关的代码移动到它自己的类中。我们使用 block 来为 cell 设置数据，也可以使用代理，依据你自己的使用习惯。 123456789101112131415161718192021@implementation ArrayDataSource- (id)itemAtIndexPath:(NSIndexPath*)indexPath &#123; return items[(NSUInteger)indexPath.row];&#125;- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section &#123; return items.count;&#125;- (UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath &#123; id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier forIndexPath:indexPath]; id item = [self itemAtIndexPath:indexPath]; configureCellBlock(cell,item); return cell;&#125;@end 这三个方法可以在视图控制器中去掉，取而代之的是你可以为这个对象创建一个实例并设置其为table view的数据源。 1234567void (^configureCell)(PhotoCell*, Photo*) = ^(PhotoCell* cell, Photo* photo) &#123; cell.label.text = photo.name;&#125;;photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos cellIdentifier:PhotoCellIdentifier configureCellBlock:configureCell];self.tableView.dataSource = photosArrayDataSource; 现在你不必担心在数组中寻找一个位置的索引，而且每当你想要将数组显示到table view上时就可以复用此代码。你还可以实现其他方法，例如：tableView:commitEditingStyle:forRowAtIndexPath:，并在table view controllers中共享这些代码。 最方便的是我们可以分开测试这个类，而且不用担心重写这些代码。如果你使用数组以外的其它东西，这个原则同样适用。 在我们今年所做的一款应用中，大量使用了Core Data。我们创建了一个类似的类，但并不是用数组作为支持，而是一个获取结果的视图控制器。它实现了所有更新动画的逻辑，并做了组头和删除。然后，你可以创建此对象的实例，并为其提供一个获取请求和一个用于设置 cell 的 block ，其余的事将会被处理的很好。 此外，这种方式也可以扩展到其它协议。显而易见的是UICollectionViewDataSource。这样将给你带来极大的便利，例如：如果在开发中的某个节点上你决定使用UITableView来代替UICollectionView，这时你会发现很难改变视图控制器中的代码。你甚至可以让你的数据源支持两种协议。 将业务逻辑放到Model中这是一段从其它应用程序中拿来的在视图控制器中搜寻用户活跃优先级的实例代码。 1234567- (void)loadPriorities &#123; NSDate* now = [NSDate date]; NSString* formatString = @&quot;startDate &lt;= %@ AND endDate &gt;= %@&quot;; NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now]; NSSet* priorities = [self.user.priorities filteredSetUsingPredicate:predicate]; self.priorities = [priorities allObjects];&#125; 然而将这段代码添加到User类的分类中会更加清晰，然后View Controller.m看起来是这个样子： 123- (void)loadPriorities &#123; self.priorities = [self.user currentPriorities];&#125; 在User+Extensions.m里 123456- (NSArray*)currentPriorities &#123; NSDate* now = [NSDate date]; NSString* formatString = @&quot;startDate &lt;= %@ AND endDate &gt;= %@&quot;; NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now]; return [[self.priorities filteredSetUsingPredicate:predicate] allObjects];&#125; 一些代码不能轻易移动到 Model 中，但仍然与模型代码相关联，为此，我们可以使用存储类： 创建缓存模型在我们示例程序的第一个版本中，有些代码是从文件中加载数据并解析。这些代码在视图控制器中： 12345678910111213- (void)readArchive &#123; NSBundle* bundle = [NSBundle bundleForClass:[self class]]; NSURL *archiveURL = [bundle URLForResource:@&quot;photodata&quot; withExtension:@&quot;bin&quot;]; NSAssert(archiveURL != nil, @&quot;Unable to find archive in bundle.&quot;); NSData *data = [NSData dataWithContentsOfURL:archiveURL options:0 error:NULL]; NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data]; _users = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&quot;users&quot;]; _photos = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&quot;photos&quot;]; [unarchiver finishDecoding];&#125; 视图控制器本不应该知道这些，为此我们创建了一个存储类来做这些。通过将这些代码分离，我们可以复用这些代码、分别测试并让视图控制器更轻量。存储类可以关心数据的加载、缓存、设置数据库堆栈。这个存储类也经常被称为服务层或仓库。 将网络处理逻辑放到Model层这与上述主题十分相似：不要在视图控制器中做网络处理逻辑。而是将它封装到不同的类中。你的视图控制器之后可以通过调用方法处理回调（例如：完成的block）。最棒的是你可以在这个类中执行所有缓存和错误处理。 将创建UI的代码放到View层在视图控制器中不应该创建复杂的视图层次结构。可以使用 Interface Builder 或者将 UI 层封装到 UIView 子类中。例如，如果你创建自己的时间选择器，将其单独封装成 DatePickerView 比将代码写到视图控制器中更说得通。这样又增加了可重用性和简单性。 如果你喜欢用 Interface Builder ，也可以这么做。有些人认为只能将其用于视图控制器，但你也可以使用自定义的 view 加载单独的 nib 文件。在我们的示例程序中，我们创建了一个 PhotoCell.xib 来包含照片 cell 的布局。 正如你所看到的，我们为这个自定义 view 创建属性并将它们关联到特定的 UIView 子类上（在这个 xib 中我们并没有使用 File’s Owner 对象）。这个技巧对于其它自定义控件也十分便利。 通信另外一件经常发生在视图控制器中事是与其它 Controller、Model、View之间的通信。虽然这是视图控制器应该做的事，也是我们想尽可能用少量代码去实现的。 这里有许多很好解释的技巧对于视图控制器和模型之间的通信（例如 KVO 和 捕获结果控制器），然而视图控制器之间的通信往往不太清楚。 我们经常遇到某个视图控制器有一些状态并与其它多个视图控制器通讯的问题。通常，将这个状态放到单独的对象中并将其传递给其它视图控制器然后观察和修改这些状态是说的通的。它的优点是状态被放到一个地方，我们最终不会陷入嵌套的委托回调。这是个复杂的问题，今后我们可能把这个问题全部归功于此。 结论我们看到了一些让视图控制器变轻的技巧。但我们不会尽可能随时随地使用这些技巧，我们只有一个目标：编写可维护的代码。通过了解这些模式，我们有更多的机会避免笨重的视图控制器，并使其更清晰。 延伸阅读 View Controller Programming Guide for iOS Cocoa Core Competencies: Controller Object Writing high quality view controllers Programmers Stack Exchange: Model View Controller Store Unburdened View Controllers Programmers Stack Exchange: How to avoid big and clumsy UITableViewControllers on iOS","categories":[{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/child/categories/翻译/"}],"tags":[]},{"title":"Linux下配置Tomcat服务器","slug":"2017-06-07-linuxxia-pei-zhi-tomcatfu-wu-qi","date":"2017-06-07T03:41:35.000Z","updated":"2017-10-13T04:11:21.000Z","comments":true,"path":"2017/06/07/2017-06-07-linuxxia-pei-zhi-tomcatfu-wu-qi/","link":"","permalink":"http://yoursite.com/child/2017/06/07/2017-06-07-linuxxia-pei-zhi-tomcatfu-wu-qi/","excerpt":"VPS买了一段时间了，平时只是用来FQ上网（如果想要购买VPS来FQ上国外网站，请参考：Mac下利用搬瓦工VPS实现科学上网），白白浪费了大好资源。今天就来说说在VPS上搭建Tomcat的过程以及遇到的坑。","text":"VPS买了一段时间了，平时只是用来FQ上网（如果想要购买VPS来FQ上国外网站，请参考：Mac下利用搬瓦工VPS实现科学上网），白白浪费了大好资源。今天就来说说在VPS上搭建Tomcat的过程以及遇到的坑。 前提 VPS已安装Linux系统（文中所有操作是在Centos 6 x86_64 minimal系统下） 本地安装SecureCRT（文中本地使用Mac OS X EI Capitan系统，下面会详细介绍SecureCRT安装过程） 安装 SecureCRTSecureCRT是一款支持SSH（SSH1和SSH2）的终端仿真程序。 这里提供8.0.4版本的百度云盘下载地址，提取码：pquq。更多版本可以到Xclinet上下载，Xclinet上有很多免费的Mac软件及破解方法，非常方便。 Tips: Xclinet上下载的软件解压密码都是xclient.info。 将 DMG 中的 SecureCRT.app 移动至 Applications 文件夹。 在Launchpad中点击打开，正常运行程序一次，然后关闭掉。 使用补丁文件夹中的 SecureCRT 文件替换以下文件 /Applications/SecureCRT.app/Contents/MacOS/SecureCRT。 正常运行应用程序，在弹出的注册页面点击 “Continue”，进入下一个界面，点击左下角的 Enter License Manually，将 README.md 中的激活码依次填入，安装成功。 安装成功后，就可以通过SecureCRT远程登录操作服务器。 安装 JDK安装Tomcat首先需要先配置JDK ，JDK下载地址。由于是为VPS安装JDK，所以需要登录远程服务器，创建一个目录用来下载安装JDK。 进入JDK下载地址，选择和cpu位数对应的tar.gz包。点击Accept License Agreement，复制链接地址。 登录远程服务器，cd到指定目录。 wget http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz(wget 下载地址) tar -xzvf jdk-8u131-linux-x64.tar.gz (解压) 若解压失败，使用sh -du *查看文件大小，如果只有几K，代表下载失败。使用下面的命令重新下载JDK。 输入命令: 1wget -c -P /java/jdk --no-check-certificate --no-cookie --header &quot;Cookie: s_nr=1479818001999; s_cc=true; s_sq=oracledevall%3D%2526pid%253Docom%25253Aen-us%25253A%25252Fcn%25252Fjava%25252Fjavase%25252Foverview%25252F%2526pidt%253D1%2526oid%253Dotn%25253Acn%25253Atab%25253Ajava%25253A%2525E4%2525B8%25258B%2525E8%2525BD%2525BD%2526oidt%253D1%2526ot%253DA%2526oi%253D1; ELOQUA=GUID=4b703a6e148b4855a6708de929b383a5; gpw_e24=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fcn%2Fjava%2Fjavase%2Fdownloads%2Fjdk7-downloads-1880260.html; oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz 还可以使用 1wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz 下载好的目录在 /java/jdk，重复第四步解压。 配置 JDK cd ~，到root路径下配置.bashrc文件 vi .bashrc，编辑.bashrc，在文件中# .bashrc下面添加以下三行代码，只需修改第一行JAVA_HOME=后的路径为刚刚解压的JDK路径即可。 123export JAVA_HOME=/java/jdk/jdk1.8.0_131export CLASSPATH=$&#123;JAVA_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH source ~/.bashrc，执行后此环境变量就生效了，不过此时要想全局生效需要重启系统。 reboot，重启系统。稍等一会儿重新连接远程服务器。 Java -version，查看Java版本，如果可以看到版本号就表示配置成功了。下面开始安装Tomcat。 安装 TomcatTomcat下载地址，和JDK的下载方式一样，这里还是下载tar.gz包。 在下载地址Binary Distributions–&gt;Core中选择tar.gz (pgp, md5, sha1)复制链接地址。 cd到指定目录。 wget https://www.apache.org/dist/tomcat/tomcat-9/v9.0.0.M21/bin/apache-tomcat-9.0.0.M21.tar.gz.sha1 tar -xzvf apache-tomcat-9.0.0.M21.tar.gz，解压。 进入解压目录的bin文件夹，运行命令./startup.sh，会出现 123456Using CATALINA_BASE: /java/apache-tomcat-9.0.0.M21Using CATALINA_HOME: /java/apache-tomcat-9.0.0.M21Using CATALINA_TMPDIR: /java/apache-tomcat-9.0.0.M21/tempUsing JRE_HOME: /java/jdk/jdk1.8.0_131Using CLASSPATH: /java/apache-tomcat-9.0.0.M21/bin/bootstrap.jar:/java/apache-tomcat-9.0.0.M21/bin/tomcat-juli.jarTomcat started. 验证是否开启服务，在浏览器输入http://服务器ip:8080，如果出现以下界面代表服务已经启动。 上传文件前期做了一大堆安装配置，其实我想要做的只是把本地写的Web demo跑到外网上去。这里我使用rz命令行上传。Linux中rz命令和sz命令都可用于文件传输。 sz：将选定的文件send(发送)到本地机器。 rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到Linux服务器。 首先借助securtCRT登录服务器执行以下操作： 1234yum install -y lrzsz # 在VPS上安装&quot;sz\\rz&quot;。cd apache-tomcat-9.0.0.M21 # apache-tomcat-9.0.0.M21是解压Tomcat后的目录cd webapps/ROOT # 进入ROOT目录rz # 这时会弹出选择文件的窗口 Tips: 上传的内容必须是文件，不能是文件夹。所以如果想要上传文件夹，只需在本地压缩上传后在服务器解压。 例如： 这里我要上传的是一个名为pet的Web项目(pet目录下有index.html、source、css)，我只需在本地压缩。然后使用rz上传到ROOT目录下，用unzip pet.zip解压，最后使用rm -rf pet.zip删除压缩包即可。访问Web项目根文件的路径规则为: http://服务器ip:8080/pet/index.html。 当然，上传文件还可以通过SFTP、FTP、SCP等方式，之后会补充完善其他上传方式。 参考文章： Linux安装JDK Linux安装Tomcat9 Linux下使用wget 命令下载JDK7的方法","categories":[{"name":"Servers","slug":"Servers","permalink":"http://yoursite.com/child/categories/Servers/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/child/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/child/tags/Tomcat/"}]},{"title":"Mac下利用搬瓦工VPS实现科学上网","slug":"2017-04-13-macxia-li-yong-ban-wa-gong-vpsshi-xian-ke-xue-shang-wang","date":"2017-04-13T09:56:34.000Z","updated":"2017-10-13T02:03:05.000Z","comments":true,"path":"2017/04/13/2017-04-13-macxia-li-yong-ban-wa-gong-vpsshi-xian-ke-xue-shang-wang/","link":"","permalink":"http://yoursite.com/child/2017/04/13/2017-04-13-macxia-li-yong-ban-wa-gong-vpsshi-xian-ke-xue-shang-wang/","excerpt":"###Step 1：购买搬瓦工VPS登录搬瓦工官网","text":"###Step 1：购买搬瓦工VPS登录搬瓦工官网 选择套餐套餐选择，一般只是用来上网的话用19.99美元一年的就比较合适，每月550G带宽足够，可根据个人用途选择套餐。搬瓦工VPSLocation，一共有洛杉矶、佛罗里达、荷兰、凤凰城4个数据中心，我们可以根据需要选择，一般我们会选择洛杉矶数据中心，因为速度比较快。具体对比信息可以去官网上找。 确认订单 支付订单支付之前，需要注册账号，需要完善相应的信息这里比较关键，我们输入个人信息，英文或者拼音都可以，邮箱是新的，密码需要正确，国家不要乱写，选择自己的国家，然后地区，路段都可以任意的拼音，但也不要乱写。先点击更新个人信息，然后勾选条款，点击付款。 最后，我们可以用支付宝、PAYPAL、信用卡付款，现在我们不需要代购，可以直接自己购买，很方便。可以选择支付宝购买，我在mac上使用Firefox、Safari浏览器打开此界面点击pay now都没有出现弹框，最后用手机完成的支付。完成以上操作，就能成功购买VPS。 ###Step 2：搭建VPS下面是搬瓦工搭建VPS过程 进入My Services 进入KiwiVM Control Panel 安装Shaowscocks服务端 安装Shaowscocks客户端下载地址：https://github.com/shadowsocks/shadowsocks-iOS/releases ，界面如下：地址填写服务器地址，端口和密码就是控制台Shadowsocks Server里生成的端口、密码。备注可以为空。这个时候就可以实现单人上网了。 ###Step 3：搬瓦工VPS shadowsocks多用户端口配置 远程登录服务器，在终端输入：ssh root@服务器ip -p 服务器端口，输入密码，KiviVM控制台Root password modification生成的密码，这个密码就是你用来远程登录服务器的密码。 依次运行以下命令：wget --no-check-certificate https://bandwagong.b0.upaiyun.com/uploads/ss.shchmod +x ss.sh./ss.sh 2&gt;&amp;1 | tee shadowsocks.log ，这里要耐心等待。安装成功会出现如下界面：卸载方法：使用root用户登录，运行以下命令： ./ss.sh uninstall多用户配置文件配置文件路径：vi /etc/shadowsocks.json按i键进入编辑模式：插入如下命令 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;端口号1&quot;:&quot;密码1&quot;, &quot;端口号2&quot;:&quot;密码2&quot;, &quot;端口号3&quot;:&quot;密码3&quot;, &quot;端口号4&quot;:&quot;密码4&quot;, &quot;端口号5&quot;:&quot;密码5&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 端口号可以自己定义，但注意不要与系统的端口重复。重启shadowsocks就可以在客户端通过设置的端口号、密码来登录。使用命令启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status ###Step 4：加速 ####安装net-speeder过程：Net-Speeder是一个linux软件，主要目的是为了解决丢包问题，实现TCP双倍发包流量，可以减少超时和提高下载速度。也就是同一个数据包发送两份，这样的话在服务器带宽充足情况下，丢包率会平方级降低。网络传输速度也会有所提升。 还是通过远程登录服务器，输入密码后在终端输入wget http://www.banwagong.me/tools/centos_net-speeder.sh,成功后显示如下 输入命令：sh centos_net-speeder.sh ，此时需要等待一段时间。可能会出现错误404，如图所示：原因是：搬瓦工的centos_net-speeder.sh文件中要去google下载一个net_speeder-v0.1.tar.gz的压缩包，而google的这个网址已经404了。 解决方法：使用命令 vi centos_net-speeder.sh 进入如下界面，找到下图红框标注的位置： 将原来的http://net-speeder.googlecode.com/files/net_speeder-v0.1.tar.gz替换为http://coding.net/u/njzhenghao/p/download/git/raw/master/net_speeder-v0.1.tar.gz，即上图框中的路径。然后保存退出。 再此执行：sh centos_net-speeder.sh，这时就会出现下面的界面： 输入nohup /usr/local/net_speeder/net_speeder venet0 &quot;ip&quot; &gt;/dev/null 2&gt;&amp;1 &amp; ，回车。 最后你就可以试着ping一下google了这时你就会发现每条数据包的后面都会加一个（DUP！），此标志就说明流量包双倍发送，加速成功。 到此为止，所有的配置工作就已经做完，你可以打开Shadowsocks客户端（小飞机）输入你的ip、端口号和密码，然后就可以去国外的网站肆意驰骋了。","categories":[{"name":"network","slug":"network","permalink":"http://yoursite.com/child/categories/network/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/child/tags/Mac/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/child/tags/网络/"}]},{"title":"AFNetworking3.0 Post JSON数据","slug":"2017-04-13-afnetworking3-dot-0-post-jsonshu-ju","date":"2017-04-13T09:42:34.000Z","updated":"2017-10-13T02:31:31.000Z","comments":true,"path":"2017/04/13/2017-04-13-afnetworking3-dot-0-post-jsonshu-ju/","link":"","permalink":"http://yoursite.com/child/2017/04/13/2017-04-13-afnetworking3-dot-0-post-jsonshu-ju/","excerpt":"使用AFNetworking3.0后网络请求由原来的AFHTTPRequestOperationManager变为AFHTTPSessionManager。一般的Post请求变成了这样：","text":"使用AFNetworking3.0后网络请求由原来的AFHTTPRequestOperationManager变为AFHTTPSessionManager。一般的Post请求变成了这样： 123456NSMutableDictionary *params = [NSMutableDictionary dictionary];params[@&quot;phoneNumber&quot;] = @&quot;18000000000&quot;;params[@&quot;password&quot;] = @&quot;123&quot;;AFHTTPSessionManager *session = [AFHTTPSessionManager manager];[session POST:@&quot;&quot; parameters:@&quot;&quot; progress:params success:nil failure:nil]; 最近后台要求我们提交post请求使用JSON格式，如{“password”:”123”,”phoneNumber”:”18000000001”}； 使用原有请求方式请求报错error:Error Domain=com.alamofire.error.serialization.response Code=-1011 “Request failed: service unavailable (503)”。如图：无意间发现MJExtension中有将字典转为JSON字符串的方法[params mj_JSONString]，然后心里默默称赞了杰哥的强大，看了下转JSON的源码，以为如此简单就可以解决问题。事实证明我还是too young too simple，控制台依旧输出错误error:Error Domain=NSCocoaErrorDomain Code=3840 “No value for key in object around character 7998.”。 无奈之下赶紧到github上翻看AFNetworking的文档，发现有这样一句话 123456JSON Parameter Encoding[[AFJSONRequestSerializer serializer] requestWithMethod:@&quot;POST&quot; URLString:URLString parameters:parameters error:nil];POST http://example.com/Content-Type: application/json&#123;&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: [1,2,3]&#125; 立马将这句话加入到网络请求当中：（方法一） 1234567// 获得请求管理者AFHTTPSessionManager *session = [AFHTTPSessionManager manager];// 设置请求格式session.requestSerializer = [AFJSONRequestSerializer serializer];[session.requestSerializer requestWithMethod:@&quot;POST&quot; URLString:URLString parameters:parameters error:nil];[session POST:@&quot;&quot; parameters:@&quot;&quot; progress:nil success:nil failure:nil]; 果不其然，这次的返回结果就正常了。 （方法二）最后在网上搜寻了一圈看到也可以使用AFURLSessionManager来做网络请求，不过AFURLSessionManager需要上传个NSData类型的数据。代码如下： 123456789101112131415NSData *postData = [parameters dataUsingEncoding:NSASCIIStringEncoding allowLossyConversion:YES];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];NSMutableURLRequest *request = [[AFJSONRequestSerializer serializer] requestWithMethod:@&quot;POST&quot; URLString:@&quot;url&quot; parameters:nil error:nil];request.timeoutInterval= [[[NSUserDefaults standardUserDefaults] valueForKey:@&quot;timeoutInterval&quot;] longValue];[request setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];[request setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Accept&quot;];[request setHTTPBody:postData];[[manager dataTaskWithRequest:request completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; if (!error) &#123; NSLog(@&quot;responseObject: %@&quot;, responseObject); &#125; else &#123; NSLog(@&quot;error: %@, %@, %@&quot;, error, response, responseObject); &#125; &#125;] resume]; 至此这个问题算是解决了，也可以正常拿到后台返回的数据。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/tags/iOS/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/child/tags/JSON/"}]},{"title":"iOS防止Button重复点击","slug":"2017-04-13-iosfang-zhi-buttonzhong-fu-dian-ji","date":"2017-04-13T09:29:18.000Z","updated":"2017-10-13T02:31:13.000Z","comments":true,"path":"2017/04/13/2017-04-13-iosfang-zhi-buttonzhong-fu-dian-ji/","link":"","permalink":"http://yoursite.com/child/2017/04/13/2017-04-13-iosfang-zhi-buttonzhong-fu-dian-ji/","excerpt":"项目中常会遇到在按钮的点击事件中去执行一些耗时操作。如果处理不当经常会出现连续多次点击push多次的情况，造成不好的用户体验。 一种情况是用户快速连续点击，这种情况无法避免。另一种情况是点击一次后响应时间太长，导致用户一直停留在点击界面，也会去再次点击按钮确认是否能执行下一个界面。虽然我们可以在用户点击一次后去显示一个HUB窗口隔绝用户操作，但我们并不清楚服务器去响应这个操作究竟需要多长时间，如果HUB指示器显示时间太长会显得响应特别慢，如果太短，用户很可能在指示器消失后再去点击Button，这时也会出现重复push多次。","text":"项目中常会遇到在按钮的点击事件中去执行一些耗时操作。如果处理不当经常会出现连续多次点击push多次的情况，造成不好的用户体验。 一种情况是用户快速连续点击，这种情况无法避免。另一种情况是点击一次后响应时间太长，导致用户一直停留在点击界面，也会去再次点击按钮确认是否能执行下一个界面。虽然我们可以在用户点击一次后去显示一个HUB窗口隔绝用户操作，但我们并不清楚服务器去响应这个操作究竟需要多长时间，如果HUB指示器显示时间太长会显得响应特别慢，如果太短，用户很可能在指示器消失后再去点击Button，这时也会出现重复push多次。 通常有三种方式解决此问题。 ####方式一如果你的Navigation是自定义的，可以重写以下方法： 123456- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; if (![[super topViewController] isKindOfClass:[viewController class]]) &#123; ／／ 如果和上一个控制器一样，隔绝此操作 [super pushViewController:viewController animated:animated]; &#125;&#125; 此中方法可以防止多次重复push，但如果你想push的下一个控制器恰好和上一个控制器类型(Class)一样，就不会push成功。所以并不推荐使用此方法。 ####方式二点击一次后将button的enabled变为NO。具体思路是：如果在button的点击事件中要做耗时操作，可能是网络请求和请求成功后的数据处理比较耗时。如果只是单纯的在请求成功和失败的回调中写一遍btn.enabled = YES就会发现如果连续点击还是会出现push多次的情况。原因可能是push操作需要时间去执行，我们在这段时间连续快速点击还是会导致push多次，感兴趣的可以去试一下。我的思路是在请求失败后单独将buuton的enabled设为YES，请求成功后不对button做任何操作。最后在- viewWillAppear方法中将button的enabled设为YES，以防在pop回本控制器的时候button不可点击。下面上代码：其中的WXDHTTPTool是封装了一层AFNetworking的网络请求类。在- viewWillAppear方法中将button的enabled设为YES：这样做也可以实现防止重复push的问题，但并不能做到一劳永逸。每个控制器都需要这么去做，虽然代码并不复杂，但方式并不优雅。 ####方式三最优雅的方式，使用Runtime监听点击事件，忽略重复点击，设置一个eventTimeInterval属性，使其规定时间内只响应一次点击事件。废话不多说，上代码。 为UIButton创建一个分类，这里我起名为WXD。 .h文件：添加一个属性eventTimeInterval，用来设置button点击间隔时间。 1234567#import &lt;UIKit/UIKit.h&gt;@interface UIButton (WXD)/** * 为按钮添加点击间隔 eventTimeInterval秒 */@property (nonatomic, assign) NSTimeInterval eventTimeInterval;@end .m文件：需要import库。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#import &quot;UIButton+WXD.h&quot;#import &lt;objc/runtime.h&gt;#define defaultInterval 1 //默认时间间隔@interface UIButton ()/** * bool YES 忽略点击事件 NO 允许点击事件 */@property (nonatomic, assign) BOOL isIgnoreEvent;@end@implementation UIButton (WXD)static const char *UIControl_eventTimeInterval = &quot;UIControl_eventTimeInterval&quot;;static const char *UIControl_enventIsIgnoreEvent = &quot;UIControl_enventIsIgnoreEvent&quot;;// runtime 动态绑定 属性- (void)setIsIgnoreEvent:(BOOL)isIgnoreEvent&#123; objc_setAssociatedObject(self, UIControl_enventIsIgnoreEvent, @(isIgnoreEvent), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (BOOL)isIgnoreEvent&#123; return [objc_getAssociatedObject(self, UIControl_enventIsIgnoreEvent) boolValue];&#125;- (NSTimeInterval)eventTimeInterval&#123; return [objc_getAssociatedObject(self, UIControl_eventTimeInterval) doubleValue];&#125;- (void)setEventTimeInterval:(NSTimeInterval)eventTimeInterval&#123; objc_setAssociatedObject(self, UIControl_eventTimeInterval, @(eventTimeInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;+ (void)load&#123; // Method Swizzling static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL selA = @selector(sendAction:to:forEvent:); SEL selB = @selector(_wxd_sendAction:to:forEvent:); Method methodA = class_getInstanceMethod(self,selA); Method methodB = class_getInstanceMethod(self, selB); BOOL isAdd = class_addMethod(self, selA, method_getImplementation(methodB), method_getTypeEncoding(methodB)); if (isAdd) &#123; class_replaceMethod(self, selB, method_getImplementation(methodA), method_getTypeEncoding(methodA)); &#125;else&#123; //添加失败了 说明本类中有methodB的实现，此时只需要将methodA和methodB的IMP互换一下即可。 method_exchangeImplementations(methodA, methodB); &#125; &#125;);&#125;- (void)_wxd_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123; self.eventTimeInterval = self.eventTimeInterval == 0 ? defaultInterval : self.eventTimeInterval; if (self.isIgnoreEvent)&#123; return; &#125;else if (self.eventTimeInterval &gt; 0)&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.eventTimeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [self setIsIgnoreEvent:NO]; &#125;); &#125; self.isIgnoreEvent = YES; // 这里看上去会陷入递归调用死循环，但在运行期此方法是和sendAction:to:forEvent:互换的，相当于执行sendAction:to:forEvent:方法，所以并不会陷入死循环。 [self _wxd_sendAction:action to:target forEvent:event];&#125; 最后就可以去在想要设置点击间隔的控制器引入分类的头文件，可以手动设置button.eventTimeInterval = 点击间隔，也可以不设任何值去使用默认的时间间隔。还可以在pch文件中引入分类头文件，让项目中所有button都添加此分类。 写在最后：如果有意见或者更优雅的解决方式，欢迎沟通交流。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/tags/iOS/"}]},{"title":"Mac下配置Apache服务器","slug":"2017-04-13-macxia-pei-zhi-apachefu-wu-qi","date":"2017-04-13T09:00:35.000Z","updated":"2017-10-13T02:42:54.000Z","comments":true,"path":"2017/04/13/2017-04-13-macxia-pei-zhi-apachefu-wu-qi/","link":"","permalink":"http://yoursite.com/child/2017/04/13/2017-04-13-macxia-pei-zhi-apachefu-wu-qi/","excerpt":"有的时候，我们需要在内网工作组中分享一些文件或是后台接口没有及时给出，你又想要模拟真实数据，直接在项目里创建plist也可以做到这种需求，但难免让工程变得冗余且看起来比较Low。这个时候就看出配置本地服务器的重要性了，不用时刻等着后台接口的更新，只需要根据接口文档自己模拟真实数据，即方便又显得高大上。","text":"有的时候，我们需要在内网工作组中分享一些文件或是后台接口没有及时给出，你又想要模拟真实数据，直接在项目里创建plist也可以做到这种需求，但难免让工程变得冗余且看起来比较Low。这个时候就看出配置本地服务器的重要性了，不用时刻等着后台接口的更新，只需要根据接口文档自己模拟真实数据，即方便又显得高大上。 Mac自带了Apache环境，我们要做的只是稍微配置一下。环境：Mac OS X 10.11 。 ###启动Apache在终端输入：sudo apachectl start，这样就将Mac自带的Apache启动了，在浏览器输入http://localhost，会显示“It works!”，说明服务器已经启动成功了。Apache默认的根目录在/Library/WebServer/Documents/下。 ###配置服务器在Finder中创建一个”Sites”的文件夹，直接创建在/Users/wan(当前用户名)目录下，如图： 切换工作目录下：cd /etc/apache2 备份文件，只需要执行一次：sudo cp httpd.conf httpd.conf.bak 如果操作出现错误！可以使用命令，恢复备份的 httpd.conf 文件：sudo cp httpd.conf.bak httpd.conf 用vim编辑httpd.conf文件，httpd.conf文件时Apache的配置文件：sudo vim httpd.conf这时候需要输入密码来获取权限，出现如下界面回车进入到下面的界面： 按住shift键，并且输入：号进入vim命令模式，搜索/DocumentRoot，找到图中对应位置将圈内路径改为之前创建的Sites文件夹的路径。 之后找到Options FollowSymLinks：修改为Options Indexes FollowSymLinks，在两个单词间添加一个Indexes单词。 接下来查找php，:/php，定位到图中位置： 将这句代码前面的＃去掉。最后:wq保存并退出。 切换工作目录：cd /etc。 拷贝php.ini文件：sudo cp php.ini.default php.ini ###重新启动apache服务器在终端输入：sudo apachectl -k restart这个时候如果在浏览器地址输入http://127.0.0.1/，就会将Sites文件夹中的目录列出来了。同一工作组里的电脑可以通过本电脑的ip地址来访问本电脑上的文件。","categories":[{"name":"Servers","slug":"Servers","permalink":"http://yoursite.com/child/categories/Servers/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/child/tags/Mac/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/child/tags/服务器/"}]},{"title":"cocoapods安装","slug":"2017-04-13-cocoapodsan-zhuang","date":"2017-04-13T07:10:29.000Z","updated":"2017-10-13T02:31:22.000Z","comments":true,"path":"2017/04/13/2017-04-13-cocoapodsan-zhuang/","link":"","permalink":"http://yoursite.com/child/2017/04/13/2017-04-13-cocoapodsan-zhuang/","excerpt":"CocoaPods是一个用来管理第三方库的比较好用的管理工具。只需要我们做好少量的配置工作,CocoaPods会为我们做好一切，将三方库更新到最新的版本。","text":"CocoaPods是一个用来管理第三方库的比较好用的管理工具。只需要我们做好少量的配置工作,CocoaPods会为我们做好一切，将三方库更新到最新的版本。 ###安装CocoaPods可以方便地通过Mac自带的RubyGems安装。 打开Terminal，然后输入以下命令：sudo gem install -n /usr/local/bin cocoapods备注：苹果系统升级 OS X EL Capitan(版本10.11.3) 后安装改为:sudo gem install -n /usr/local/bin cocoapods，10.11之前用sudo gem install cocoapods。执行完这句如果报告以下错误：这时需要需要更新一下ruby的源(原因：被墙了)，将ruby的镜像rubygems.org指向淘宝，输入以下命令： gem sources -l (查看当前ruby的源) 移除现有 Ruby 默认源 gem sources --remove https://rubygems.org/ 将Ruby源指向淘宝镜像 gem sources -a https://ruby.taobao.org/ gem sources -l 如果gem版本太老，可以尝试用如下命令升级gemsudo gem update --system升级成功后会提示: RubyGems system software updated,如图： 检查pod 是否安装pod --version 在这里能检测到版本就代表已经安装如果出现pod: command not found，说明还没有安装pod如果已安装想要重新安装，输入以下命令卸载pod：sudo gem uninstall cocoapods 然后执行安装下载命令sudo gem install -n /usr/local/bin cocoapods这里可能会报错，activesupport requires Ruby version &gt;= 2.2.2.更新Ruby环境，这里使用rvm对Ruby进行升级。安装rvm，RVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)a. 终端输入：curl -L get.rvm.io | bash -s stableb. 依次输入以下命令：source ~/.bashrcsource ~/.bash_profilesource ~/.profilervm -v如果出现下面的提示： 输入以下命令，若没有上面的提示，则直接跳过本步骤 rvm reload rvm -vc. 查看当前ruby版本 ,获取rvm 列表ruby -vrvm list knownd. 安装Rubyrvm install 2.3出现Install of ruby-2.3.0 - #complete ，说明ruby2.3.0已经安装完成了。e. 再次使用：sudo gem install -n /usr/local/bin cocoapods ，这里会提示输入密码，出现如下界面： 接下来进行安装，执行： pod setup Terminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下。（说明Cocoapods在将它的信息下载到 ~/.cocoapods里，cd ~/.cocoapods 到该目录里，用du -sh *命令来查看文件大小，每隔一段时间查看一次，我的这个目录最终大小是786M） 安装成功后会出现下面的界面，说明安装成功了。 ###使用 新建一个项目，在终端cd到该项目的根目录下，使用vim Podfile ，新建一个名为Podfile的文件，在键盘上按 i 进入编辑模式，如图：pod版本1.0.1以后，需要输入以下格式，并添加需要的库并保存，这里是MBProgressHUD： 1234platform :ios,&apos;8.0&apos;target &apos;项目名&apos; dopod &apos;MBProgressHUD&apos;, &apos;~&gt; 1.0.0&apos;end 按esc键退出编辑模式，然后按住shift键，并且输入“ ：”号进入vim命令模式，然后在冒号后边输入wq，回车，退出编辑。 终端输入：pod install ，等几分钟后就会出现下面的界面到这里就说明项目里已经添加了pod，重新打开项目的目录会看到多出一个PodTest.xcworkspace文件，现在打开项目不是点击 PodTest.xodeproj了，而是点击 PodTest.xcworkspace。项目结构就会变为： 如果需要导入多个三方库只需在终端cd到项目根目录，再次使用 vim Podfile ，编辑之前的Podfile文件，修改完了Podfile文件，需要重新执行一次pod install命令。 补充： 使用：pod search &lt;三方库名&gt; 来查找最新的三方库，如：pod search AFNetWorking拷贝圈中代码，按 q 退出，cd到项目目录，使用$ vim Podfile ，添加pod ‘AFNetworking’, ‘~&gt; 3.1.0’ ，重新执行一次pod install命令，就可以将最新的库添加到项目中。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/categories/iOS/"}],"tags":[{"name":"cocoapods","slug":"cocoapods","permalink":"http://yoursite.com/child/tags/cocoapods/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/child/tags/安装/"}]},{"title":"iOS与H5交互遇到的坑","slug":"2017-04-13-iosyu-h5jiao-hu-yu-dao-de-keng","date":"2017-04-13T06:31:47.000Z","updated":"2017-10-13T02:31:05.000Z","comments":true,"path":"2017/04/13/2017-04-13-iosyu-h5jiao-hu-yu-dao-de-keng/","link":"","permalink":"http://yoursite.com/child/2017/04/13/2017-04-13-iosyu-h5jiao-hu-yu-dao-de-keng/","excerpt":"之前的博客写过使用库来实现与H5的交互，但是在项目中还是遇到了一些不得不踩的坑。在这里将我遇到的问题以及参考网上几位大神的解决方案列举出来，如果有更好的办法，欢迎讨论指正。在阅读本博客前，请参阅我之前的iOS与H5交互。","text":"之前的博客写过使用库来实现与H5的交互，但是在项目中还是遇到了一些不得不踩的坑。在这里将我遇到的问题以及参考网上几位大神的解决方案列举出来，如果有更好的办法，欢迎讨论指正。在阅读本博客前，请参阅我之前的iOS与H5交互。 ###问题一在webView中加载H5界面，webView中的H5一级界面可以轻松实现oc与js方法互调，但如果在H5界面上进入二级界面，二级界面中再使用之前方法来交互就会失效。如图：左图为H5一级界面，右图为二级界面。 解决办法： 第一步：在控制器中声明两个变量，isNotFirstLoad用来记录webView是否是第一次加载网页；loadCount计数器，用来记录网页转跳次数，做返回处理。 第二步：实现以下方法： 123456789101112131415161718192021222324252627282930313233- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; // isNotFirstLoad,记录webView是否第一次加载H5页面 if (isNotFirstLoad) &#123; CGRect frame = self.webView.frame; [self.webView removeFromSuperview]; [self.animationView removeFromSuperview]; UIWebView *webView = [[UIWebView alloc] initWithFrame:frame]; webView.delegate = self; [self.view addSubview:webView]; [webView loadRequest:request]; self.webView = webView; //首先创建JSContext 对象（此处通过当前webView的键获取到jscontext） JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; //创建JSTestObjext对象，赋值给js的对象 JSTestObjext *test = [JSTestObjext new]; test.delegate = self; context[@&quot;iOS&quot;] = test; isNotFirstLoad = NO; return NO; &#125; isNotFirstLoad = YES; // 计数器，用来记录网页转跳次数，做返回处理 loadCount ++; if (loadCount == 3) &#123; loadCount = 1; &#125; return YES;&#125; 在网页转跳二级界面的时候重新创建UIWebView和JSContext对象，将其当成一个新的网页，再使用JSContext对象来实现交互的时候就不会出现失效的情况。 第三步：此时在H5二级界面互调方法就不会有问题了，但新的问题又出现了，当点击返回按钮的时候如何返回上级界面。这时就要用到申明的loadCount成员变量了。具体代码写在自定义返回按钮的点击事件中，我在项目中导航栏是自定义的，重写返回按钮只需重写导航栏的leftBarButtonItem。代码如下： 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; self.title = self.webTitle; // 设置导航栏返回按钮 self.navigationItem.leftBarButtonItem = [UIBarButtonItem itemWithIcon:@&quot;nav_menu_back_02&quot; highlighted:@&quot;nav_menu_back_03&quot; target:self action:@selector(backClick)]; [self createUI];&#125; 返回按钮点击事件代码如下： 12345678910111213/** * 返回按钮点击事件 */- (void)backClick&#123; if (loadCount == 1) &#123; // pop到上级VC [self.navigationController popViewControllerAnimated:YES]; &#125;else&#123; // 如果计数器为2,重新加载一级界面的url NSURL *url = [NSURL URLWithString:self.url]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; [self.webView loadRequest:request]; &#125;&#125; 到此这个问题算是解决了。 ###问题二当H5界面中嵌套视频，在用手机横屏播放视频，点击右上角完成按钮退出播放界面的时候，会出现导航栏上移，与状态栏重合的bug。如图：左图为正常进入H5界面的样子，点击视频播放按钮，进入视频播放界面，打开手机的竖排方向锁定，在手机横屏时候播放器会自动横屏播放，这时点击播放起左上角完成按钮活着右下角全屏按钮退出播放界面就会出现右图的bug，导航栏会向上移动，与状态栏重合。 解决方法： 第一步：在AppDelegate.h中增加一个属性值，用来设置是否允许横屏。代码如下： 12345678910#import &lt;UIKit/UIKit.h&gt;@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@property (strong, nonatomic) UIWindow *window;/*** 是否允许横屏的标记 */@property (nonatomic,assign)BOOL allowRotation;@end 在AppDelegate.m中实现 123456789/** * 是否允许横屏 */- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(nullable UIWindow *)window&#123; if (self.allowRotation) &#123; return UIInterfaceOrientationMaskAll; &#125; return UIInterfaceOrientationMaskPortrait;&#125; 在加载webView的控制器中注册两个通知，通过监听UIWindow是否可见来判断视频播放器是否出现。在viewDidLoad中注册通知，见代码： 123456789101112131415161718192021222324252627282930// 播放视频，监听视频播放器 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(begainFullScreen) name:UIWindowDidBecomeVisibleNotification object:nil];//进入全屏 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(endFullScreen) name:UIWindowDidBecomeHiddenNotification object:nil];//退出全屏实现通知方法：- (void)begainFullScreen&#123; AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate]; appDelegate.allowRotation = YES;&#125;/** * 退出全屏 */- (void)endFullScreen&#123; AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate]; appDelegate.allowRotation = NO; // 设置设备方向为竖排 if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget:[UIDevice currentDevice]]; int val = UIInterfaceOrientationPortrait; [invocation setArgument:&amp;val atIndex:2]; [invocation invoke]; &#125;&#125; Tips: 获取appDelegate需要引入头文件#import “AppDelegate.h”。这样就可以避免导航栏上移出现的bug。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/tags/iOS/"},{"name":"iOS与H5交互","slug":"iOS与H5交互","permalink":"http://yoursite.com/child/tags/iOS与H5交互/"},{"name":"H5","slug":"H5","permalink":"http://yoursite.com/child/tags/H5/"},{"name":"交互","slug":"交互","permalink":"http://yoursite.com/child/tags/交互/"},{"name":"遇到的坑","slug":"遇到的坑","permalink":"http://yoursite.com/child/tags/遇到的坑/"}]},{"title":"iOS与H5交互","slug":"2017-04-13-iosyu-h5jiao-hu","date":"2017-04-13T05:32:50.000Z","updated":"2017-09-23T11:58:39.000Z","comments":true,"path":"2017/04/13/2017-04-13-iosyu-h5jiao-hu/","link":"","permalink":"http://yoursite.com/child/2017/04/13/2017-04-13-iosyu-h5jiao-hu/","excerpt":"搬家了，搬家了，将自己博客园中的几篇阅读量较高的博客搬到自己的个人主页。 前提：在iOS控制器中加载UIWebView，设置代理，遵守UIWebViewDelegate协议。","text":"搬家了，搬家了，将自己博客园中的几篇阅读量较高的博客搬到自己的个人主页。 前提：在iOS控制器中加载UIWebView，设置代理，遵守UIWebViewDelegate协议。 ###iOS调用JS方法通过iOS调用JS代码实现起来比较方便直接调用UIWebView的方法 1- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 查询标签 1234// 查询标签NSString *str = @&quot;var word = document.getElementById(&apos;word&apos;);&quot; @&quot;alert(word.innerHTML)&quot;;[webView stringByEvaluatingJavaScriptFromString:str]; 为网页添加标签 123456NSString *str = @&quot;var img = document.createElement(&apos;img&apos;);&quot; &quot;img.src = &apos;icon5.jpg&apos;;&quot; &quot;img.width = 300;&quot; &quot;img.heigth = 100;&quot; &quot;document.body.appendChild(img);&quot;;[webView stringByEvaluatingJavaScriptFromString:str]; 更改标签 1234// 更改NSString *str2 = @&quot;var change = document.getElementsByClassName(&apos;change&apos;)[0];&quot; &quot;change.innerHTML = &apos;hello&apos;;&quot;;NSString *result = [webView stringByEvaluatingJavaScriptFromString:str2]; HTML端代码: 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;iOS和H5交互&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;word&quot;&gt;6666666666&lt;/p&gt; &lt;ul&gt; &lt;li class=&quot;change&quot;&gt;111111&lt;/li&gt; &lt;li class=&quot;haha&quot;&gt;222222&lt;/li&gt; &lt;li&gt;333333&lt;/li&gt; &lt;li&gt;444444&lt;/li&gt; &lt;/ul&gt; &lt;input class=&quot;name&quot; placeholder=&quot;请输入密码&quot;&gt; &lt;button onclick=&quot;buttonClick()&quot;&gt;提交信息&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; alert(&apos;这个一个弹框&apos;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ###JS调用iOS方法 第一种方法比较简单，通过字符串的比对。这种方式iOS端代码比较简单，网页加载完成后后台需要重新定义网页url，将移动端需要的参数拼接到url上返回，或者按照和后台约定好的字段来进行字符串比对以达到调用iOS方法的目的。下面贴代码。oc代码：(需要实现webView的协议) 1234567891011121314151617181920212223// 拦截协议头，调取系统摄像头#pragma mark UIWebViewDelegate- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType: (UIWebViewNavigationType)navigationType&#123; NSString *str = request.URL.absoluteString; if ([str containsString:@&quot;wxd://&quot;]) &#123; [self getImage]; &#125; return YES;&#125;- (void)getImage&#123; if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary]) &#123; //调用相册 //实例化控制器 UIImagePickerController *picker = [[UIImagePickerController alloc] init]; picker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary; picker.delegate = self; // 是否有图片选取框 picker.allowsEditing = YES; [self presentViewController:picker animated:YES completion:nil]; &#125;&#125; HTML端代码 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;在html中调用oc的方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;getImage()&quot;&gt;访问相册&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; function getImage()&#123; window.location.href = &quot;wxd://getImage&quot;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第二种方法，JS直接用oc方法名来调用oc方法，类似于安卓.addJavascriptInterface(new JsObject(), “Android”)方法，头文件需要导入#import 首先创建一个继承自NSObject的类，在这里我命名为JSTestObjext，.h代码如下：.m中实现协议方法，代码如下：之后在加载webView的控制器中调用：到此为止，oc代码就已经写完了，我们只需告诉JS端使用testobject类，就可以调oc的方法了。下面附上JS调用的代码： 到此公司里所使用的iOS与H5交互的方法就都写在这里了。使用第二种方法，库来实现交互遇到的问题，已经写到了另一篇博客当中iOS与H5交互遇到的坑。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/child/tags/iOS/"},{"name":"iOS与H5交互","slug":"iOS与H5交互","permalink":"http://yoursite.com/child/tags/iOS与H5交互/"},{"name":"H5","slug":"H5","permalink":"http://yoursite.com/child/tags/H5/"},{"name":"交互","slug":"交互","permalink":"http://yoursite.com/child/tags/交互/"}]},{"title":"在两台设备间同步Octopress博客","slug":"2017-04-12-zai-liang-tai-she-bei-jian-tong-bu-ni-de-octopressbo-ke","date":"2017-04-12T09:39:24.000Z","updated":"2017-10-23T06:19:02.000Z","comments":true,"path":"2017/04/12/2017-04-12-zai-liang-tai-she-bei-jian-tong-bu-ni-de-octopressbo-ke/","link":"","permalink":"http://yoursite.com/child/2017/04/12/2017-04-12-zai-liang-tai-she-bei-jian-tong-bu-ni-de-octopressbo-ke/","excerpt":"本文翻译自：Clone Your Octopress to Blog From Two Places 这篇博文阐述了怎样在本地重建Octopress博客的代码库。你可能意外的丢失了本地代码，也有可能你想在两个不同的地方更新博客。最近我买了一台新电脑，而我想要在自己的台式机和笔记本上同时更新博客内容。","text":"本文翻译自：Clone Your Octopress to Blog From Two Places 这篇博文阐述了怎样在本地重建Octopress博客的代码库。你可能意外的丢失了本地代码，也有可能你想在两个不同的地方更新博客。最近我买了一台新电脑，而我想要在自己的台式机和笔记本上同时更新博客内容。 ###Octopress如何工作Octopress仓库包含了两个分支：source和master。source分支包含了生成博客所需的文件，master分支包含博客自己的内容。当按照Octopress设置指南进行初始化配置的时候会在本地生成一个名为Octopress的文件夹，master分支被存储在Octopress下的_deploy文件夹内。因为_deploy文件夹的名字以下划线开头，所以当你执行git push origin source的时候会被忽略。然而包含博客提交内容的master分支在执行rake deploy命令的时候会被同步到远程服务器。 ###重建本地代码库为已存在的博客重建本地目录结构，遵循以下说明。 ####复制博客到新的设备首先你需要将source分支复制到本地的octopress文件夹中。 1$ git clone -b source git@github.com:username/username.github.com.git octopress 然后复制master分支到_deploy子文件夹内。 12$ cd octopress$ git clone git@github.com:username/username.github.com.git _deploy 然后执行安装命令部署环境 1234$ gem install bundler$ rbenv rehash # If you use rbenv, rehash to be able to run the bundle command$ bundle install$ rake setup_github_pages 这里将提示你输入远程仓库的路径 12Enter the read/write url for your repository(For example, &apos;git@github.com:your_username/your_username.github.com) 这样你就在本地建立了一份博客的新副本。 ###从两台不同设备提交改动如果你想在多台电脑上写博客，你需要确保在变换电脑之前提交所有改动。在第一台设备上无论你做任何改动都需要做以下操作。 12345$ rake generate$ git add .$ git commit -am &quot;Some comment here.&quot; $ git push origin source # update the remote source branch $ rake deploy # update the remote master branch 然后在另一台设备上，你需要获取这些变动。 1234$ cd octopress$ git pull origin source # update the local source branch$ cd ./_deploy$ git pull origin master # update the local master branch 当然，使用U盘部署可能会更加简单。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/child/categories/翻译/"}],"tags":[{"name":"Octopress","slug":"Octopress","permalink":"http://yoursite.com/child/tags/Octopress/"},{"name":"同步","slug":"同步","permalink":"http://yoursite.com/child/tags/同步/"}]},{"title":"Octopress个性化配置","slug":"2017-04-11-octopressge-xing-hua-pei-zhi","date":"2017-04-11T08:34:16.000Z","updated":"2017-10-23T06:19:56.000Z","comments":true,"path":"2017/04/11/2017-04-11-octopressge-xing-hua-pei-zhi/","link":"","permalink":"http://yoursite.com/child/2017/04/11/2017-04-11-octopressge-xing-hua-pei-zhi/","excerpt":"上篇文章主要讲了使用Octopress搭建个人博客，关于博客的个性化配置将在这篇文章中细述。","text":"上篇文章主要讲了使用Octopress搭建个人博客，关于博客的个性化配置将在这篇文章中细述。 ###自定义域名创建了个人博客后，很多小伙伴都迫不及待的想要注册自己的域名了吧。阿里云、腾讯云注册域名都很方便，注册方式这里不再赘述，还没有的小伙伴赶紧去注册自己的域名吧。 这里参照了网上的两种方案。 ####方案一 在终端输入：userName.github.io``` ，找到ANSWER SECTION行，会看到项目所在IP地址，如下图：![image](http://oo6qj81tq.bkt.clouddn.com/58e9bccc55f0d0qe5bc41414cffbf1c8.png)1234567* 修改域名解析记录，添加一个A记录，记录值为上面得到的IP。大致长这样：![image](http://oo6qj81tq.bkt.clouddn.com/88e9bccc55f0d01e5bc41414cffbf110.png)* 登录`http://github.com` --&gt; 进入`userName.github.io`项目 --&gt; `Settings` --&gt; `Custom domain` --&gt; 输入你的域名`example.com` --&gt; `Save`。![image](http://oo6qj81tq.bkt.clouddn.com/88e9bccc55f0d01e5bc41414cffbf111.png) 浏览器输入example.com(即注册好的域名)即可浏览博客。__Note:__ 此方式缺点是当通过`rake generate`重新生成静态网页,`rake deploy`提交到GitHub的时候,之前在`Settings` --&gt; `Custom domain`中填写的域名就会被置空，造成博客地址404错误。重新填写网页又可以正常访问，但每次rake deploy都要这么去做难免有点繁琐。所以推荐方案二，简单，一劳永逸。####方案二* 在你的本地站点`Octopress`目录里的`source`目录下添加一个`CNAME`文件: cd octopress/source # 进入source目录touch CNAME # 创建一个CNAME文件vim CNAME # 使用vim编辑器打开,在里面添加你的域名信息（这里不加http://）12![image](http://oo6qj81tq.bkt.clouddn.com/88e9bccc55f0d01e5bc41414cffbf112.png)保存退出,生成静态网页并提交到GitHub。 cd .. # 返回到octopress根目录rake generate # 生成静态网页git add . # 保存到缓存区git commit -m “log” # 提交代码git push origin source # 将source分支同步到GitHub服务器rake deploy # 将master分支同步到GitHub服务器12345* 登录域名服务商后台，因为我用的是顶级域名，所以添加一条A记录。记录值为@(Tips:@ 将域名解析为`example.com`（不带www），填写@或者不填写；)。根据自己的需求这里可以添加不同的域名解析记录，具体填写那种记录GitHub在文档中已经说的很清楚了，地址在这[Using a custom domain with GitHub Pages](https://help.github.com/articles/using-a-custom-domain-with-github-pages/#setting-up-an-apex-domain)。添加完记录后稍等一会，域名服务商后台提示要等至少10分钟才会解析成功，这里我我等了大约1分钟就生效了，然后打开你的浏览器输入你购买的域名尝试吧。###自定义导航栏* 创建一个页面`about`，默认保存路径在`source\\about\\index.markdown`。 rake new_page[‘about’] # 新建about界面vim source/_includes/custom/navigation.html # 编辑navigation.html12345* 更改过后的代码如下:![image](http://oo6qj81tq.bkt.clouddn.com/88e9bccc55f0d01e5bc41414cffbf114.png)* 接下来，就可以编辑`source\\about\\index.markdown`的内容了。使用Markdown编辑器打开`index.markdown`进行编辑即可。###添加文章分类* 增加`category_list`插件:在`plugins`目录下编辑`category_list_tag.rb`文件 vim plugins/category_list_tag.rb ＃ 编辑category_list_tag.rb文件，若没有则新建1添加下面的代码到`category_list_tag.rb`中，完成后保存退出。 module Jekyll class CategoryListTag &lt; Liquid::Tag def render(context) html = “” categories = context.registers[:site].categories.keys categories.sort.each do |category| posts_in_category = context.registers[:site].categories[category].size category_dir = context.registers[:site].config[‘category_dir’] category_url = File.join(categorydir, category.gsub(/|\\P{Word}/, ‘-‘).gsub(/-{2,}/, ‘-‘).downcase) html &lt;&lt; “#{category} (#{posts_in_category})\\n” end html end endend Liquid::Template.register_tag(‘category_list’, Jekyll::CategoryListTag)1* 增加aside vim source/_includes/asides/category_list.html ＃ 编辑category_list.html，若没有则新建1复制以下代码到category_list.html中，完成后保存退出。 文章分类 {% category_list %} 12* 最后修改`_config.yml`,`cd`到`octopress`根目录。 vim _config.yml12345678910找到`default_asides:`，在中括号中添加`asides/category_list.html`。Tips：添加的位置决定在页面显示的位置。* 其他：在`_config.yml`中，把`Read on`改为“`继续阅读`”。在`source/_includes/custom/asides`目录下，将&quot;`Recent Comments`&quot;改为&quot;`最新评论`&quot;，&quot;`Categories`&quot;改为&quot;`分类目录`&quot;，将`source/_includes/asides/recent_posts.html` 中&quot;`Recent Posts`&quot;改为&quot;`最新文章`&quot;。 ###首页显示文章摘要默认情况下，首页会展示文章的全部内容，若只想在首页显示部分内容需要做一些简单的配置。* 在需要展示的文字后添加省略标记 1* 编辑`_config.yml`，找到`excerpt_link`修改对应文字 excerpt_link: “阅读全部→”123456789* 保存退出，`rake generate`重新部署。###更换第三方主题__Note:__更换主题后默认的octopress主题会被覆盖，若想要恢复默认只需重新执行`rake install`。而且 `abacus`主题不支持侧栏显示，这里只是简单的举个例子。Octopress默认的主题怎么能体现出广大程序员对个性的追求，下面介绍怎么为自己的博客更换个性主题。这里是一些主题的地址：[传送门](https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes)。大家可以在上面找自己中意的主题，这里我用 `abacus` 来举例说明。* 选中一款自己喜欢的主题，这里的每款主题都有详细的安装方法。[abacus地址](https://github.com/bhrigu123/abacus)* 在终端执行以下命令。 cd octopressgit clone https://github.com/bhrigu123/abacus .themes/abacusrake install[‘abacus’]rake generaterake preview # 预览主题1* 浏览器输入`localhost:4000`查看效果无误后提交到GitHub。 git add .git commit -m ‘Change blog theme.’git push origin sourcerake deploy``` 其他：在source/images中替换avatar.jpg来自定义头像；在source/_includes/custom/navigation_links.html中编辑标签来自定义导航栏(与上面编辑source/_includes/custom/navigation.html类似)。切记完成操作后执行rake generate命令。 Tips: 若想要接入评论系统和更多个性化设置请看这里。 ###参考文章： 自定义你的Octopress博客 Octopress安装和配置 octopress博客搭建和个性化配置","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/child/categories/HTML/"}],"tags":[{"name":"octopress","slug":"octopress","permalink":"http://yoursite.com/child/tags/octopress/"},{"name":"个性化配置","slug":"个性化配置","permalink":"http://yoursite.com/child/tags/个性化配置/"}]},{"title":"octopress + GitHub Page 搭建个人博客","slug":"2017-04-07-octopress-plus-github-page-da-jian-ge-ren-bo-ke","date":"2017-04-07T08:33:17.000Z","updated":"2017-10-23T06:20:10.000Z","comments":true,"path":"2017/04/07/2017-04-07-octopress-plus-github-page-da-jian-ge-ren-bo-ke/","link":"","permalink":"http://yoursite.com/child/2017/04/07/2017-04-07-octopress-plus-github-page-da-jian-ge-ren-bo-ke/","excerpt":"近几个月以来没有怎么写博客，一方面是因为工作比较忙，另一方面自己的私事比较多。近期也会将博客园上自己写的几篇觉得可以的文章搬过来。顺便说一句，三月底终于把拖了快三年的驾照拿到手了，这是件值得庆贺的事。再说最近，项目基本就是迭代，工作量不大。所以趁着时间比较充裕，打算将这个习惯继续下去。开博客对我本人来说，只是一种对自己学习经历的记录。这件事权当是种锻炼，凡事总是由不会到会，由不懂到懂。学习是一条孤独且漫长的路，只有进步才能让人更充实。","text":"近几个月以来没有怎么写博客，一方面是因为工作比较忙，另一方面自己的私事比较多。近期也会将博客园上自己写的几篇觉得可以的文章搬过来。顺便说一句，三月底终于把拖了快三年的驾照拿到手了，这是件值得庆贺的事。再说最近，项目基本就是迭代，工作量不大。所以趁着时间比较充裕，打算将这个习惯继续下去。开博客对我本人来说，只是一种对自己学习经历的记录。这件事权当是种锻炼，凡事总是由不会到会，由不懂到懂。学习是一条孤独且漫长的路，只有进步才能让人更充实。​首先说明两个关键术语： ###Octopress Octopress是基于 Jekyll 的博客框架。他们的关系就像 jQuery 与 js 的关系一样。 它为我们提供了现成的美观的主题模板，并且配置简单，使用方便，大大降低了我们建站的门槛。###What is Octopress?(摘自Octopress官方文档)Octopress is Jekyll blogging at its finest. Octopress sports a clean responsive theme written in semantic HTML5, focused on readability and friendliness toward mobile devices. Code blogging is easy and beautiful. Embed code (with Solarized styling) in your posts from gists, jsFiddle or from your filesystem. Third party integration is simple with built-in support for Pinboard, Delicious, GitHub Repositories, Disqus Comments and Google Analytics. It’s easy to use. A collection of rake tasks simplifies development and makes deploying a cinch. Ships with great plug-ins some original and others from the Jekyll community — tested and improved. Note: Octopress requires a minimum Ruby version of 1.9.3-p0. ###GitHub Pages GitHub Pages 是 GitHub 提供的一项服务。它用于显示托管在 GitHub 上的静态网页。所以我们可以用 Github Pages 搭建博客，当然我们也可以把项目的文档和主页放在上面。 大致思路是通过Octopress生成本地静态博客网页，然后将静态网页布置到GitHub提供的GitHub Pages上面。 ###安装 下面是具体的安装步骤(这里使用RVM安装，还可以通过rbenv安装，Octopress给出的官方安装文档：Octopress Setup)： ####查看ruby版本1ruby --version # 根据Octopress官方文档Ruby必须 &gt;= 1.9.3-p0 如果ruby版本 &gt;= 1.9.3-p0 ，跳过RVM和Ruby的安装。 ####安装RVM1curl -L https://get.rvm.io | bash -s stable --ruby ####安装Ruby 1.9.3123rvm install 1.9.3rvm use 1.9.3rvm rubygems latest ####安装 Octopress将 Octopress的项目clone到本地: 12git clone git://github.com/imathis/octopress.git octopresscd octopress 更新ruby源,将官方的ruby源替换成国内淘宝的源。 123gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l 接下来，安装依赖： 12gem install bundler # 若遇权限问题加上sudo重新执行，并输入密码。bundle install 最后安装 Octopress 1rake install # 安装octopress默认主题 ####修改Octopress初始配置12ls # 查看当前目录所有文件vim _config.yml # 通过vim编辑主要配置 可以看到如下代码： 123456789101112131415# ----------------------- ## Main Configs ## ----------------------- ##网站地址，这里是GitHub项目地址,为必填url: http://userName.github.io#网站标题 title: user的博客#网站副标题subtitle: 天行健，君子以自强不息。#网址作者author: userName#搜索引擎simple_search: https://www.google.com/search#网站的描述，出现在HTML页面中的 meta 中的 descriptiondescription: 确保在octopress目录，执行命令 12rake generate # 生成静态站点rake preview # 预览静态站点，在http://localhost:4000 在浏览器输入localhost:4000可看到生成的博客。Tips: 最好把里面的twitter相关的信息全部删掉，否则由于GFW的原因，将会造成页面load很慢。 ###部署到GitHub Pages上在 GitHub 上创建一个New repository,Repository name即项目名称命名规则为 userName.github.io，userName必须与用户名称一致。Tips:最好不要勾选README，免得同步到远程仓库的时候需要做额外的pull操作。 将本地代码仓库同步到GitHub. 1rake setup_github_pages 绑定远程仓库 1git@github.com:your_username/your_username.github.io.git # 或者https://github.com/your_username/your_username.github.io 创建一篇文章 1rake new_post[&quot;title&quot;] 生成新的文章在source/_posts/目录下 12cd source/_posts # 命令行cd到posts目录下open ./ # 打开目录文件夹 这个时候会在目录里看到.markdown后缀的文件，我们可以通过一些第三方的Markdown编辑器打开。在这里我使用的是Mou(下载地址：这里)，Mou附带实时预览，文档说明里也将markdown语法说的很详细，这里不再赘述。 编辑完成后生成静态站点，终端执行命令： 1rake generate # 此命令需在octopress根目录执行，若当前目录为source/_posts，执行两次cd ..返回到根目录再执行此命令。 预览本地的站点，执行指令： 1rake preview 在浏览器打开localhost:4000 查看网页效果效果。如果没有问题就可以将静态站点同步到 GitHub远程仓库中。 最后，提交远程仓库。Octopress的Git仓库(repository)有两个分支，分别是master和source。 source分支存储的是生成博客的源文件，在octopress根目录下。 master分支存储的是博客网站本身master的内容，在根目录的_deploy文件夹内，当你push源文件时会忽略，它使用rake deploy命令来更新。 1234git add .git commit -m &quot;comment&quot; ＃&quot;comment&quot;为提交的log日志git push origin sourcerake deploy ＃同步到GitHub服务器 打开GitHub稍等一会儿再刷新，就会看到我们的网页已经被同步到GitHub仓库的master分支上了。浏览器访问访问username.github.io，就会发现个人博客已经创建成功了。 git操作代码如下： 123456git remote -v # 显示所有远程仓库git pull origin source # 取回远程仓库的变化git branch # 列出所有本地分支git checkout [branch-name] # 切换到指定分支，并更新工作区git merge [branch] # 合并指定分支到当前分支git log # 查看当前分支的版本历史 Tips: 关于Octopress的个性化配置和在多台设备间同步使用，会在之后的文章中更新。 ###参考文章： 象写程序一样写博客：搭建基于github的博客 制作个人博客站（一）：Mac系统下使用 Octopress + GitHub Pages 搭建个人博客 octopress博客搭建和个性化配置 Octopress重装或者多台电脑上并行写作同步","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/child/categories/HTML/"}],"tags":[{"name":"octopress","slug":"octopress","permalink":"http://yoursite.com/child/tags/octopress/"},{"name":"GitHub Page","slug":"GitHub-Page","permalink":"http://yoursite.com/child/tags/GitHub-Page/"},{"name":"个人博客","slug":"个人博客","permalink":"http://yoursite.com/child/tags/个人博客/"}]}]}